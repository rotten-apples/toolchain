From 61b5ffa3d6535ae812f459169e10958539e7b17a Mon Sep 17 00:00:00 2001
From: mark@chromium.org <mark@chromium.org>
Date: Fri, 20 Mar 2009 20:22:15 +0000
Subject: [PATCH 1/8] Snapshot local changes to ld64.

git-svn-id: http://toolwhip.googlecode.com/svn/trunk@16 e278dae4-13f1-11de-b480-edb48bd02f47
---
 Makefile.linux                                     |    2 +
 README.toolwhip                                    |   14 ++
 src/Makefile.linux                                 |    2 +
 src/ld/ArchiveReader.hpp                           |    5 +
 src/ld/MachOReaderRelocatable.hpp                  |    1 +
 src/ld/MachOWriterExecutable.hpp                   |   23 +-
 src/ld/Makefile.linux                              |   35 +++
 src/ld/Options.cpp                                 |   19 ++-
 src/ld/arc4random-fbsd.c                           |  231 ++++++++++++++++++++
 src/ld/arc4random.h                                |   16 ++
 src/ld/gen_uuid-uuid.c                             |   82 +++++++
 src/ld/ld.cpp                                      |   39 +++-
 src/ld/ld_version.c                                |    1 +
 src/ld/pack-uuid.c                                 |   70 ++++++
 src/ld/strl.h                                      |   16 ++
 src/ld/strlcpy-fbsd.c                              |   70 ++++++
 src/ld/unpack-uuid.c                               |   64 ++++++
 src/ld/uuid.h                                      |   17 ++
 src/ld/uuidP.h                                     |   26 +++
 src/other/rebase.cpp                               |   12 +-
 unit-tests/src/xmlparser/xmlparser.1               |  156 +++++++-------
 unit-tests/src/xmlparser/xmlparser.m               |   50 ++--
 .../test-cases/exported_symbols_list-eol/test.exp  |    3 +-
 23 files changed, 825 insertions(+), 129 deletions(-)
 create mode 100644 Makefile.linux
 create mode 100644 README.toolwhip
 create mode 100644 src/Makefile.linux
 create mode 100644 src/ld/Makefile.linux
 create mode 100644 src/ld/arc4random-fbsd.c
 create mode 100644 src/ld/arc4random.h
 create mode 100644 src/ld/gen_uuid-uuid.c
 create mode 100644 src/ld/ld_version.c
 create mode 100644 src/ld/pack-uuid.c
 create mode 100644 src/ld/strl.h
 create mode 100644 src/ld/strlcpy-fbsd.c
 create mode 100644 src/ld/unpack-uuid.c
 create mode 100644 src/ld/uuid.h
 create mode 100644 src/ld/uuidP.h

diff --git a/Makefile.linux b/Makefile.linux
new file mode 100644
index 0000000..3e40e95
--- /dev/null
+++ b/Makefile.linux
@@ -0,0 +1,2 @@
+all clean: src
+	@for i in $^ ; do $(MAKE) -C $${i} -f Makefile.linux $@ ; done
diff --git a/README.toolwhip b/README.toolwhip
new file mode 100644
index 0000000..134079c
--- /dev/null
+++ b/README.toolwhip
@@ -0,0 +1,14 @@
+Home: http://www.opensource.apple.com/darwinsource/
+URL: http://www.opensource.apple.com/darwinsource/tarballs/apsl/ld64-85.2.1.tar.gz
+Version: ld64 85.2.1 (Xcode Tools 3.1.2)
+License: APSL
+License File: APPLE_LICENSE
+Local Vendor Branch: http://toolwhip.googlecode.com/svn/vendor/ld64
+Local Trunk: http://toolwhip.googlecode.com/svn/trunk/ld64
+
+Description:
+ld64 is the Mac OS X linker.
+
+Local Modifications:
+Only this file, README.toolwhip, has been added to the local vendor branch.
+All other local modifications are made on the local trunk.
diff --git a/src/Makefile.linux b/src/Makefile.linux
new file mode 100644
index 0000000..4fa8f98
--- /dev/null
+++ b/src/Makefile.linux
@@ -0,0 +1,2 @@
+all clean: ld
+	@for i in $^ ; do $(MAKE) -C $${i} -f Makefile.linux $@ ; done
diff --git a/src/ld/ArchiveReader.hpp b/src/ld/ArchiveReader.hpp
index b8f1a5c..2bcf471 100644
--- a/src/ld/ArchiveReader.hpp
+++ b/src/ld/ArchiveReader.hpp
@@ -43,6 +43,11 @@
 #if LTO_SUPPORT
 	#include "LTOReader.hpp"
 #endif
+
+/* From cctools-698.1/include/stuff/ofile.h */
+#ifndef AR_EFMT1
+#define AR_EFMT1	"#1/"		/* extended format #1 */
+#endif
  
 namespace archive {
 
diff --git a/src/ld/MachOReaderRelocatable.hpp b/src/ld/MachOReaderRelocatable.hpp
index 2aa7926..1e3dfdc 100644
--- a/src/ld/MachOReaderRelocatable.hpp
+++ b/src/ld/MachOReaderRelocatable.hpp
@@ -39,6 +39,7 @@
 #include "ObjectFile.h"
 #include "dwarf2.h"
 #include "debugline.h"
+#include "strl.h"
 
 #include <libunwind/DwarfInstructions.hpp>
 #include <libunwind/AddressSpace.hpp>
diff --git a/src/ld/MachOWriterExecutable.hpp b/src/ld/MachOWriterExecutable.hpp
index 5313669..22716b7 100644
--- a/src/ld/MachOWriterExecutable.hpp
+++ b/src/ld/MachOWriterExecutable.hpp
@@ -25,14 +25,15 @@
 #ifndef __EXECUTABLE_MACH_O__
 #define __EXECUTABLE_MACH_O__
 
+#include <signal.h>
 #include <stdint.h>
 #include <stddef.h>
 #include <fcntl.h>
 #include <sys/time.h>
-#include <uuid/uuid.h>
+#include "uuid.h"
 #include <mach/i386/thread_status.h>
 #include <mach/ppc/thread_status.h>
-#include <CommonCrypto/CommonDigest.h>
+#include <openssl/md5.h>
 
 #include <vector>
 #include <algorithm>
@@ -6180,19 +6181,19 @@ uint64_t Writer<A>::writeAtoms()
 
 		// update content based UUID
 		if ( fOptions.getUUIDMode() == Options::kUUIDContent ) {
-			uint8_t digest[CC_MD5_DIGEST_LENGTH];
+			uint8_t digest[MD5_DIGEST_LENGTH];
 			if ( streaming ) {
 				// if output file file did not fit in memory, re-read file to generate md5 hash
 				uint32_t kMD5BufferSize = 16*1024;
 				uint8_t* md5Buffer = (uint8_t*)::malloc(kMD5BufferSize);
 				if ( md5Buffer != NULL ) {
-					CC_MD5_CTX md5State;
-					CC_MD5_Init(&md5State);
+					MD5_CTX md5State;
+					MD5_Init(&md5State);
 					::lseek(fd, 0, SEEK_SET);
 					ssize_t len;
 					while ( (len = ::read(fd, md5Buffer, kMD5BufferSize)) > 0 ) 
-						CC_MD5_Update(&md5State, md5Buffer, len);
-					CC_MD5_Final(digest, &md5State);
+						MD5_Update(&md5State, md5Buffer, len);
+					MD5_Final(digest, &md5State);
 					::free(md5Buffer);
 				}
 				else {
@@ -6208,10 +6209,10 @@ uint64_t Writer<A>::writeAtoms()
 				// if output file fit in memory, just genrate an md5 hash in memory
 			#if 1
 				// temp hack for building on Tiger
-				CC_MD5_CTX md5State;
-				CC_MD5_Init(&md5State);
-				CC_MD5_Update(&md5State, wholeBuffer, size);
-				CC_MD5_Final(digest, &md5State);
+				MD5_CTX md5State;
+				MD5_Init(&md5State);
+				MD5_Update(&md5State, wholeBuffer, size);
+				MD5_Final(digest, &md5State);
 			#else
 				CC_MD5(wholeBuffer, size, digest);
 			#endif
diff --git a/src/ld/Makefile.linux b/src/ld/Makefile.linux
new file mode 100644
index 0000000..354ecf6
--- /dev/null
+++ b/src/ld/Makefile.linux
@@ -0,0 +1,35 @@
+NULL =
+
+CFILES_ld64 = \
+	arc4random-fbsd.c \
+	debugline.c \
+	gen_uuid-uuid.c \
+	ld_version.c \
+	pack-uuid.c \
+	strlcpy-fbsd.c \
+	unpack-uuid.c \
+	$(NULL)
+COBJS_ld64 = $(CFILES_ld64:.c=.o)
+
+CCFILES_ld64 = \
+	Options.cpp \
+	ld.cpp \
+	$(NULL)
+CCOBJS_ld64 = $(CCFILES_ld64:.cpp=.o)
+
+XCFLAGS = -D__LITTLE_ENDIAN__ -I../../usr_include -I../abstraction -I/usr/include/xnu -I.
+
+all: ld64
+
+ld64: $(COBJS_ld64) $(CCOBJS_ld64)
+	$(CXX) -o $@ $^ -lcrypto
+
+.c.o:
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+.cpp.o:
+	$(CXX) $(CXXFLAGS) $(XCFLAGS) -c -o $@ $<
+
+clean:
+	-rm -rf \
+	  ld64 $(COBJS_ld64) $(CCOBJS_ld64) \
diff --git a/src/ld/Options.cpp b/src/ld/Options.cpp
index 492d140..3f351f4 100644
--- a/src/ld/Options.cpp
+++ b/src/ld/Options.cpp
@@ -30,10 +30,10 @@
 #include <fcntl.h>
 #include <vector>
 
-#include "configure.h"
 #include "Options.h"
 #include "Architectures.hpp"
 #include "MachOFileAbstraction.hpp"
+#include "strl.h"
 
 extern void printLTOVersion(Options &opts);
 
@@ -97,8 +97,15 @@ Options::Options(int argc, const char* argv[])
 	  fMinimumHeaderPad(32), fSegmentAlignment(4096), 
 	  fCommonsMode(kCommonsIgnoreDylibs),  fUUIDMode(kUUIDContent), fLocalSymbolHandling(kLocalSymbolsAll), fWarnCommons(false), 
 	  fVerbose(false), fKeepRelocations(false), fWarnStabs(false),
-	  fTraceDylibSearching(false), fPause(false), fStatistics(false), fPrintOptions(false),
-	  fSharedRegionEligible(false), fPrintOrderFileStatistics(false),  
+	  fTraceDylibSearching(false), fPause(false), 
+#ifdef GENUINE_MACH
+	  fStatistics(false),
+#endif /* GENUINE_MACH */
+	  fPrintOptions(false),
+	  fSharedRegionEligible(false),
+#ifdef GENUINE_MACH
+	  fPrintOrderFileStatistics(false),  
+#endif /* GENUINE_MACH */
 	  fReadOnlyx86Stubs(false), fPositionIndependentExecutable(false), 
 	  fDisablePositionIndependentExecutable(false), fMaxMinimumHeaderPad(false),
 	  fDeadStripDylibs(false),  fAllowTextRelocs(false), fWarnTextRelocs(false), 
@@ -1841,9 +1848,11 @@ void Options::parse(int argc, const char* argv[])
 			else if ( strcmp(arg, "-order_file") == 0 ) {
 				parseOrderFile(argv[++i], false);
 			}
+#ifdef GENUINE_MACH
 			else if ( strcmp(arg, "-order_file_statistics") == 0 ) {
 				fPrintOrderFileStatistics = true;
 			}
+#endif /* GENUINE_MACH */
 			// ??? Deprecate segcreate.
 			// -sectcreate puts whole files into a section in the output.
 			else if ( (strcmp(arg, "-sectcreate") == 0) || (strcmp(arg, "-segcreate") == 0) ) {
@@ -2352,9 +2361,11 @@ void Options::parse(int argc, const char* argv[])
 			else if ( strcmp(arg, "-pause") == 0 ) {
 				fPause = true;
 			}
+#ifdef GENUINE_MACH
 			else if ( strcmp(arg, "-print_statistics") == 0 ) {
 				fStatistics = true;
 			}
+#endif /* GENUINE_MACH */
 			else if ( strcmp(arg, "-d") == 0 ) {
 				fReaderOptions.fMakeTentativeDefinitionsReal = true;
 			}
@@ -2754,8 +2765,10 @@ void Options::parsePreCommandLineEnvironmentSettings()
 	if (fReaderOptions.fTraceDylibs || fReaderOptions.fTraceArchives)
 		fReaderOptions.fTraceOutputFile = getenv("LD_TRACE_FILE");
 
+#ifdef GENUINE_MACH
 	if (getenv("LD_PRINT_ORDER_FILE_STATISTICS") != NULL)
 		fPrintOrderFileStatistics = true;
+#endif /* GENUINE_MACH */
 
 	if (getenv("LD_SPLITSEGS_NEW_LIBRARIES") != NULL)
 		fSplitSegs = true;
diff --git a/src/ld/arc4random-fbsd.c b/src/ld/arc4random-fbsd.c
new file mode 100644
index 0000000..ef82567
--- /dev/null
+++ b/src/ld/arc4random-fbsd.c
@@ -0,0 +1,231 @@
+/* Libc-498.1.1/gen/arc4random-fbsd.c (modified) */
+/*
+ * Arc4 random number generator for OpenBSD.
+ * Copyright 1996 David Mazieres <dm@lcs.mit.edu>.
+ *
+ * Modification and redistribution in source and binary forms is
+ * permitted provided that due credit is given to the author and the
+ * OpenBSD project (for instance by leaving this copyright notice
+ * intact).
+ */
+
+/*
+ * This code is derived from section 17.1 of Applied Cryptography,
+ * second edition, which describes a stream cipher allegedly
+ * compatible with RSA Labs "RC4" cipher (the actual description of
+ * which is a trade secret).  The same algorithm is used as a stream
+ * cipher called "arcfour" in Tatu Ylonen's ssh package.
+ *
+ * Here the stream cipher has been modified always to include the time
+ * when initializing the state.  That makes it impossible to
+ * regenerate the same random sequence twice, so this can't be used
+ * for encryption, but will generate good random numbers.
+ *
+ * RC4 is a registered trademark of RSA Laboratories.
+ */
+
+#include "arc4random.h"
+
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+
+struct arc4_stream {
+	u_int8_t i;
+	u_int8_t j;
+	u_int8_t s[256];
+};
+
+static pthread_mutex_t	arc4random_mtx = PTHREAD_MUTEX_INITIALIZER;
+
+#define	RANDOMDEV	"/dev/urandom"
+#define	THREAD_LOCK()						\
+	do {							\
+		pthread_mutex_lock(&arc4random_mtx);		\
+	} while (0)
+
+#define	THREAD_UNLOCK()						\
+	do {							\
+		pthread_mutex_unlock(&arc4random_mtx);		\
+	} while (0)
+
+static struct arc4_stream rs;
+static int rs_initialized;
+static int rs_stired;
+
+static inline u_int8_t arc4_getbyte(struct arc4_stream *);
+static void arc4_stir(struct arc4_stream *);
+
+static inline void
+arc4_init(as)
+	struct arc4_stream *as;
+{
+	int     n;
+
+	for (n = 0; n < 256; n++)
+		as->s[n] = n;
+	as->i = 0;
+	as->j = 0;
+}
+
+static inline void
+arc4_addrandom(as, dat, datlen)
+	struct arc4_stream *as;
+	u_char *dat;
+	int     datlen;
+{
+	int     n;
+	u_int8_t si;
+
+	as->i--;
+	for (n = 0; n < 256; n++) {
+		as->i = (as->i + 1);
+		si = as->s[as->i];
+		as->j = (as->j + si + dat[n % datlen]);
+		as->s[as->i] = as->s[as->j];
+		as->s[as->j] = si;
+	}
+}
+
+static void
+arc4_stir(as)
+	struct arc4_stream *as;
+{
+	int     fd, n;
+	struct {
+		struct timeval tv;
+		pid_t pid;
+		u_int8_t rnd[128 - sizeof(struct timeval) - sizeof(pid_t)];
+	}       rdat;
+
+	gettimeofday(&rdat.tv, NULL);
+	rdat.pid = getpid();
+	fd = open(RANDOMDEV, O_RDONLY, 0);
+	if (fd >= 0) {
+		(void) read(fd, rdat.rnd, sizeof(rdat.rnd));
+		close(fd);
+	} 
+	/* fd < 0?  Ah, what the heck. We'll just take whatever was on the
+	 * stack... */
+
+	arc4_addrandom(as, (u_char *) &rdat, sizeof(rdat));
+
+	/*
+	 * Throw away the first N bytes of output, as suggested in the
+	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
+	 * by Fluher, Mantin, and Shamir.  N=1024 is based on
+	 * suggestions in the paper "(Not So) Random Shuffles of RC4"
+	 * by Ilya Mironov.
+	 */
+	for (n = 0; n < 1024; n++)
+		arc4_getbyte(as);
+}
+
+static inline u_int8_t
+arc4_getbyte(as)
+	struct arc4_stream *as;
+{
+	u_int8_t si, sj;
+
+	as->i = (as->i + 1);
+	si = as->s[as->i];
+	as->j = (as->j + si);
+	sj = as->s[as->j];
+	as->s[as->i] = sj;
+	as->s[as->j] = si;
+
+	return (as->s[(si + sj) & 0xff]);
+}
+
+static inline u_int32_t
+arc4_getword(as)
+	struct arc4_stream *as;
+{
+	u_int32_t val;
+
+	val = arc4_getbyte(as) << 24;
+	val |= arc4_getbyte(as) << 16;
+	val |= arc4_getbyte(as) << 8;
+	val |= arc4_getbyte(as);
+
+	return (val);
+}
+
+static void
+arc4_check_init(void)
+{
+	if (!rs_initialized) {
+		arc4_init(&rs);
+		rs_initialized = 1;
+	}
+}
+
+static void
+arc4_check_stir(void)
+{
+	if (!rs_stired) {
+		arc4_stir(&rs);
+		rs_stired = 1;
+	}
+}
+
+void
+arc4random_stir()
+{
+	THREAD_LOCK();
+	arc4_check_init();
+	arc4_stir(&rs);
+	THREAD_UNLOCK();
+}
+
+void
+arc4random_addrandom(dat, datlen)
+	u_char *dat;
+	int     datlen;
+{
+	THREAD_LOCK();
+	arc4_check_init();
+	arc4_check_stir();
+	arc4_addrandom(&rs, dat, datlen);
+	THREAD_UNLOCK();
+}
+
+u_int32_t
+arc4random()
+{
+	u_int32_t rnd;
+
+	THREAD_LOCK();
+	arc4_check_init();
+	arc4_check_stir();
+	rnd = arc4_getword(&rs);
+	THREAD_UNLOCK();
+
+	return (rnd);
+}
+
+#if 0
+/*-------- Test code for i386 --------*/
+#include <stdio.h>
+#include <machine/pctr.h>
+int
+main(int argc, char **argv)
+{
+	const int iter = 1000000;
+	int     i;
+	pctrval v;
+
+	v = rdtsc();
+	for (i = 0; i < iter; i++)
+		arc4random();
+	v = rdtsc() - v;
+	v /= iter;
+
+	printf("%qd cycles\n", v);
+}
+#endif
diff --git a/src/ld/arc4random.h b/src/ld/arc4random.h
new file mode 100644
index 0000000..52a4894
--- /dev/null
+++ b/src/ld/arc4random.h
@@ -0,0 +1,16 @@
+#ifndef _ARC4RANDOM_H
+#define _ARC4RANDOM_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+u_int32_t arc4random();
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _ARC4RANDOM_H */
diff --git a/src/ld/gen_uuid-uuid.c b/src/ld/gen_uuid-uuid.c
new file mode 100644
index 0000000..7b9678c
--- /dev/null
+++ b/src/ld/gen_uuid-uuid.c
@@ -0,0 +1,82 @@
+/* Libc-498.1.1/uuid/gen_uuid-uuid.c (partial) */
+/*
+ * gen_uuid.c --- generate a DCE-compatible uuid
+ *
+ * Copyright (C) 1996, 1997, 1998, 1999 Theodore Ts'o.
+ *
+ * %Begin-Header%
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * %End-Header%
+ */
+
+#include "uuid.h"
+#include <sys/types.h>
+#include <string.h>
+#include "arc4random.h"
+#include "uuidP.h"
+
+/*
+ * Generate a series of random bytes, using arc4random
+ */
+static void get_random_bytes(void *buf, int nbytes)
+{
+	unsigned char *cp = (unsigned char *) buf;
+	u_int32_t u;
+	int n = nbytes / sizeof(u);
+
+	while (n-- > 0) {
+		u = arc4random();
+		memcpy(cp, &u, sizeof(u));
+		cp += sizeof(u);
+	}
+	if ((n = nbytes % sizeof(u)) > 0) {
+		u = arc4random();
+		memcpy(cp, &u, n);
+	}
+	return;
+}
+
+void uuid_generate_random(uuid_t out)
+{
+	uuid_t	buf;
+	struct uuid uu;
+
+	get_random_bytes(buf, sizeof(buf));
+	uuid_unpack(buf, &uu);
+
+	uu.clock_seq = (uu.clock_seq & 0x3FFF) | 0x8000;
+	uu.time_hi_and_version = (uu.time_hi_and_version & 0x0FFF) | 0x4000;
+	uuid_pack(&uu, out);
+}
+
+/*
+ * This is the generic front-end
+ */
+void uuid_generate(uuid_t out)
+{
+	uuid_generate_random(out);
+}
diff --git a/src/ld/ld.cpp b/src/ld/ld.cpp
index 115240e..4139c0c 100644
--- a/src/ld/ld.cpp
+++ b/src/ld/ld.cpp
@@ -20,11 +20,6 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
-// start temp HACK for cross builds
-extern "C" double log2 ( double );
-#define __MATH__
-// end temp HACK for cross builds
 
 
 #include <stdlib.h>
@@ -51,9 +46,7 @@ extern "C" double log2 ( double );
 #include <algorithm>
 #include <ext/hash_map>
 #include <dlfcn.h>
-#include <AvailabilityMacros.h>
 
-#include "configure.h"
 #include "Options.h"
 
 #include "ObjectFile.h"
@@ -372,10 +365,14 @@ private:
 	void				markLive(ObjectFile::Atom& atom, Linker::WhyLiveBackChain* previous);
 	void				collectStabs(ObjectFile::Reader* reader, std::map<const class ObjectFile::Atom*, uint32_t>& atomOrdinals);
 	void				synthesizeDebugNotes(std::vector<class ObjectFile::Atom*>& allAtomsByReader);
+#ifdef GENUINE_MACH
 	void				printStatistics();
 	void				printTime(const char* msg, uint64_t partTime, uint64_t totalTime);
+#endif /* GENUINE_MACH */
 	char*				commatize(uint64_t in, char* out);
+#ifdef GENUINE_MACH
 	void				getVMInfo(vm_statistics_data_t& info);
+#endif /* GENUINE_MACH */
 	cpu_type_t			inferArchitecture();
 	void				checkDylibClientRestrictions(ObjectFile::Reader* reader);
 	void				logDylib(ObjectFile::Reader* reader, bool indirect);
@@ -490,6 +487,7 @@ private:
 	uint64_t											fOutputFileSize;
 	uint64_t											fTotalZeroFillSize;
 	uint64_t											fTotalSize;
+#ifdef GENUINE_MACH
 	uint64_t											fStartTime;
 	uint64_t											fStartCreateReadersTime;
 	uint64_t											fStartCreateWriterTime;
@@ -499,6 +497,7 @@ private:
 	uint64_t											fStartDebugTime;
 	uint64_t											fStartWriteTime;
 	uint64_t											fEndTime;
+#endif /* GENUINE_MACH */
 	uint64_t											fTotalObjectSize;
 	uint64_t											fTotalArchiveSize;
 	uint32_t											fTotalObjectLoaded;
@@ -521,9 +520,11 @@ Linker::Linker(int argc, const char* argv[])
 	  fCurrentObjCConstraint(ObjectFile::Reader::kObjcNone), fCurrentCpuConstraint(ObjectFile::Reader::kCpuAny),
 	  fObjcReplacmentClasses(false), fAllDirectDylibsLoaded(false)
 {
+#ifdef GENUINE_MACH
 	fStartTime = mach_absolute_time();
 	if ( fOptions.printStatistics() )
 		getVMInfo(fStartVMInfo);
+#endif /* GENUINE_MACH */
 
 	fArchitecture = fOptions.architecture();
 	if ( fArchitecture == 0 ) {
@@ -664,7 +665,9 @@ private:
 
 void Linker::loadAndResolve()
 {
+#ifdef GENUINE_MACH
 	fStartLoadAndResolveTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 	if ( fOptions.deadStrip() == Options::kDeadStripOff ) {
 		// without dead-code-stripping:
 		// find atoms to resolve all undefines
@@ -843,12 +846,15 @@ void Linker::link()
 	this->writeDotOutput();
 	this->collectDebugInfo();
 	this->writeOutput();
+#ifdef GENUINE_MACH
 	this->printStatistics();
+#endif /* GENUINE_MACH */
 
 	if ( fOptions.pauseAtEnd() )
 		sleep(10);
 }
 
+#ifdef GENUINE_MACH
 void Linker::printTime(const char* msg, uint64_t partTime, uint64_t totalTime)
 {
 	static uint64_t sUnitsPerSecond = 0;
@@ -874,6 +880,7 @@ void Linker::printTime(const char* msg, uint64_t partTime, uint64_t totalTime)
 		fprintf(stderr, "%s: %u.%u seconds (%u.%u%%)\n", msg, seconds, secondsTimeTen-seconds*10, percent, percentTimesTen-percent*10);
 	}
 }
+#endif /* GENUINE_MACH */
 
 char* Linker::commatize(uint64_t in, char* out)
 {
@@ -891,6 +898,7 @@ char* Linker::commatize(uint64_t in, char* out)
 	return result;
 }
 
+#ifdef GENUINE_MACH
 void Linker::getVMInfo(vm_statistics_data_t& info)
 {
 	mach_msg_type_number_t count = sizeof(vm_statistics_data_t) / sizeof(natural_t);
@@ -927,6 +935,7 @@ void Linker::printStatistics()
 		fprintf(stderr, "wrote output file            totaling %15s bytes\n", commatize(fOutputFileSize, temp));
 	}
 }
+#endif /* GENUINE_MACH */
 
 inline void Linker::addAtom(ObjectFile::Atom& atom)
 {
@@ -1084,7 +1093,9 @@ void Linker::logArchive(ObjectFile::Reader* reader)
 
 void Linker::buildAtomList()
 {
+#ifdef GENUINE_MACH
 	fStartBuildAtomsTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 	// add initial undefines from -u option
 	std::vector<const char*>& initialUndefines = fOptions.initialUndefines();
 	for (std::vector<const char*>::iterator it=initialUndefines.begin(); it != initialUndefines.end(); it++) {
@@ -1845,6 +1856,9 @@ void Linker::processDTrace()
 	if ( fOptions.outputKind() == Options::kObjectFile )
 		return;
 
+#ifndef DARWIN_RUNTIME
+	return;
+#else
 	// scan all atoms looking for dtrace probes
 	std::vector<DTraceProbeInfo>						probeSites;
 	std::vector<DTraceProbeInfo>						isEnabledSites;
@@ -2004,6 +2018,7 @@ void Linker::processDTrace()
 			throw "error creating dtrace DOF section";
 		}
 	}
+#endif /* DARWIN_RUNTIME */
 }
 
 
@@ -2124,7 +2139,9 @@ void Linker::sortSections()
 //
 void Linker::sortAtoms()
 {
+#ifdef GENUINE_MACH
 	fStartSortTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 	// if -order_file is used, build map of atom ordinal overrides
 	std::map<const ObjectFile::Atom*, uint32_t>* ordinalOverrideMap = NULL;
 	std::map<const ObjectFile::Atom*, uint32_t> theOrdinalOverrideMap;
@@ -3070,7 +3087,9 @@ void Linker::synthesizeDebugNotes(std::vector<class ObjectFile::Atom*>& allAtoms
 void Linker::collectDebugInfo()
 {
 	std::map<const class ObjectFile::Atom*, uint32_t>	atomOrdinals;
+#ifdef GENUINE_MACH
 	fStartDebugTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 	if ( fOptions.readerOptions().fDebugInfoStripping != ObjectFile::ReaderOptions::kDebugInfoNone ) {
 
 		// determine mixture of stabs and dwarf
@@ -3178,7 +3197,9 @@ void Linker::writeOutput()
 	if ( fOptions.forceCpuSubtypeAll() )
 		fCurrentCpuConstraint = ObjectFile::Reader::kCpuAny;
 
+#ifdef GENUINE_MACH
 	fStartWriteTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 	// tell writer about each segment's atoms
 	fOutputFileSize = fOutputFile->write(fAllAtoms, fStabs, this->entryPoint(true), 
 											fCreateUUID, fCanScatter, 
@@ -3478,7 +3499,9 @@ void Linker::processDylibs()
 
 void Linker::createReaders()
 {
+#ifdef GENUINE_MACH
 	fStartCreateReadersTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 	std::vector<Options::FileInfo>& files = fOptions.getInputFiles();
 	const int count = files.size();
 	if ( count == 0 )
@@ -3706,7 +3729,9 @@ void Linker::logTraceInfo (const char* format, ...)
 
 void Linker::createWriter()
 {
+#ifdef GENUINE_MACH
 	fStartCreateWriterTime = mach_absolute_time();
+#endif /* GENUINE_MACH */
 
 	// make a vector out of all required dylibs in fDylibMap
 	std::vector<ExecutableFile::DyLibUsed>	dynamicLibraries;
diff --git a/src/ld/ld_version.c b/src/ld/ld_version.c
new file mode 100644
index 0000000..55dc6c0
--- /dev/null
+++ b/src/ld/ld_version.c
@@ -0,0 +1 @@
+const char ldVersionString[]= "@(#)PROGRAM:ld  PROJECT:ld64-85.2.1\n";
diff --git a/src/ld/pack-uuid.c b/src/ld/pack-uuid.c
new file mode 100644
index 0000000..4cb78cb
--- /dev/null
+++ b/src/ld/pack-uuid.c
@@ -0,0 +1,70 @@
+/* Libc-498.1.1/uuid/pack-uuid.c */
+/*
+ * Internal routine for packing UUID's
+ * 
+ * Copyright (C) 1996, 1997 Theodore Ts'o.
+ *
+ * %Begin-Header%
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * %End-Header%
+ */
+
+#include <string.h>
+#include "uuidP.h"
+
+void uuid_pack(const struct uuid *uu, uuid_t ptr)
+{
+	u_int32_t	tmp;
+	unsigned char	*out = ptr;
+
+	tmp = uu->time_low;
+	out[3] = (unsigned char) tmp;
+	tmp >>= 8;
+	out[2] = (unsigned char) tmp;
+	tmp >>= 8;
+	out[1] = (unsigned char) tmp;
+	tmp >>= 8;
+	out[0] = (unsigned char) tmp;
+	
+	tmp = uu->time_mid;
+	out[5] = (unsigned char) tmp;
+	tmp >>= 8;
+	out[4] = (unsigned char) tmp;
+
+	tmp = uu->time_hi_and_version;
+	out[7] = (unsigned char) tmp;
+	tmp >>= 8;
+	out[6] = (unsigned char) tmp;
+
+	tmp = uu->clock_seq;
+	out[9] = (unsigned char) tmp;
+	tmp >>= 8;
+	out[8] = (unsigned char) tmp;
+
+	memcpy(out+10, uu->node, 6);
+}
+
diff --git a/src/ld/strl.h b/src/ld/strl.h
new file mode 100644
index 0000000..6b1ae5e
--- /dev/null
+++ b/src/ld/strl.h
@@ -0,0 +1,16 @@
+#ifndef _STRL_H
+#define _STRL_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+size_t strlcpy(char*, const char*, size_t);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _STRL_H */
diff --git a/src/ld/strlcpy-fbsd.c b/src/ld/strlcpy-fbsd.c
new file mode 100644
index 0000000..b8e42e7
--- /dev/null
+++ b/src/ld/strlcpy-fbsd.c
@@ -0,0 +1,70 @@
+/* Libc-498.1.1/string/strlcpy-fbsd.c */
+/*	$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $	*/
+
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char *rcsid = "$OpenBSD: strlcpy.c,v 1.4 1999/05/01 18:56:41 millert Exp $";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <string.h>
+
+/*
+ * Copy src to string dst of size siz.  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz == 0).
+ * Returns strlen(src); if retval >= siz, truncation occurred.
+ */
+size_t strlcpy(dst, src, siz)
+	char *dst;
+	const char *src;
+	size_t siz;
+{
+	char *d = dst;
+	const char *s = src;
+	size_t n = siz;
+
+	/* Copy as many bytes as will fit */
+	if (n != 0 && --n != 0) {
+		do {
+			if ((*d++ = *s++) == 0)
+				break;
+		} while (--n != 0);
+	}
+
+	/* Not enough room in dst, add NUL and traverse rest of src */
+	if (n == 0) {
+		if (siz != 0)
+			*d = '\0';		/* NUL-terminate dst */
+		while (*s++)
+			;
+	}
+
+	return(s - src - 1);	/* count does not include NUL */
+}
diff --git a/src/ld/unpack-uuid.c b/src/ld/unpack-uuid.c
new file mode 100644
index 0000000..e19e4fb
--- /dev/null
+++ b/src/ld/unpack-uuid.c
@@ -0,0 +1,64 @@
+/* Libc-498.1.1/uuid/unpack-uuid.c */
+/*
+ * Internal routine for unpacking UUID
+ * 
+ * Copyright (C) 1996, 1997 Theodore Ts'o.
+ *
+ * %Begin-Header%
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * %End-Header%
+ */
+
+#include <string.h>
+#include "uuidP.h"
+
+void uuid_unpack(const uuid_t in, struct uuid *uu)
+{
+	const u_int8_t	*ptr = in;
+	u_int32_t		tmp;
+
+	tmp = *ptr++;
+	tmp = (tmp << 8) | *ptr++;
+	tmp = (tmp << 8) | *ptr++;
+	tmp = (tmp << 8) | *ptr++;
+	uu->time_low = tmp;
+
+	tmp = *ptr++;
+	tmp = (tmp << 8) | *ptr++;
+	uu->time_mid = tmp;
+	
+	tmp = *ptr++;
+	tmp = (tmp << 8) | *ptr++;
+	uu->time_hi_and_version = tmp;
+
+	tmp = *ptr++;
+	tmp = (tmp << 8) | *ptr++;
+	uu->clock_seq = tmp;
+
+	memcpy(uu->node, ptr, 6);
+}
+
diff --git a/src/ld/uuid.h b/src/ld/uuid.h
new file mode 100644
index 0000000..584ae56
--- /dev/null
+++ b/src/ld/uuid.h
@@ -0,0 +1,17 @@
+#ifndef _UUID_H
+#define _UUID_H
+
+typedef unsigned char uuid_t[16];
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void uuid_generate_random(uuid_t);
+void uuid_generate(uuid_t);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _UUID_H */
diff --git a/src/ld/uuidP.h b/src/ld/uuidP.h
new file mode 100644
index 0000000..26e2ffa
--- /dev/null
+++ b/src/ld/uuidP.h
@@ -0,0 +1,26 @@
+#ifndef _UUIDP_H
+#define _UUIDP_H
+
+#include <sys/types.h>
+#include "uuid.h"
+
+struct uuid {
+  u_int32_t time_low;
+  u_int16_t time_mid;
+  u_int16_t time_hi_and_version;
+  u_int16_t clock_seq;
+  u_int8_t node[6];
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void uuid_pack(const struct uuid*, uuid_t);
+void uuid_unpack(const uuid_t, struct uuid*);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _UUIDP_H */
diff --git a/src/other/rebase.cpp b/src/other/rebase.cpp
index f8dc1ee..893964c 100644
--- a/src/other/rebase.cpp
+++ b/src/other/rebase.cpp
@@ -755,7 +755,11 @@ void Rebaser<x86_64>::setRelocBase()
 static void copyFile(const char* srcFile, const char* dstFile)
 {
 	// open files 
+#ifdef O_DIRECT
+	int src = open(srcFile, O_RDONLY | O_DIRECT);	
+#else
 	int src = open(srcFile, O_RDONLY);	
+#endif
 	if ( src == -1 )
 		throwf("can't open file %s, errno=%d", srcFile, errno);
 	struct stat stat_buf;
@@ -769,7 +773,9 @@ static void copyFile(const char* srcFile, const char* dstFile)
 		throwf("can't create temp file %s, errnor=%d", dstFile, errno);
 
 	// mark source as "don't cache"
+#ifdef F_NOCACHE
 	(void)fcntl(src, F_NOCACHE, 1);
+#endif
 	// we want to cache the dst because we are about to map it in and modify it
 	
 	// copy permission bits
@@ -783,10 +789,8 @@ static void copyFile(const char* srcFile, const char* dstFile)
 	const uint32_t kBufferSize = 128*1024;
 	static uint8_t* buffer = NULL;
 	if ( buffer == NULL ) {
-		vm_address_t addr = 0;
-		if ( vm_allocate(mach_task_self(), &addr, kBufferSize, true /*find range*/) == KERN_SUCCESS )
-			buffer = (uint8_t*)addr;
-		else
+		buffer = (uint8_t*)malloc(kBufferSize);
+		if (!buffer)
 			throw "can't allcoate copy buffer";
 	}
 	while ( (len = read(src, buffer, kBufferSize)) > 0 ) {
diff --git a/unit-tests/src/xmlparser/xmlparser.1 b/unit-tests/src/xmlparser/xmlparser.1
index 6eab06a..be5dec5 100644
--- a/unit-tests/src/xmlparser/xmlparser.1
+++ b/unit-tests/src/xmlparser/xmlparser.1
@@ -1,79 +1,79 @@
-.\"Modified from man(1) of FreeBSD, the NetBSD mdoc.template, and mdoc.samples.
-.\"See Also:
-.\"man mdoc.samples for a complete listing of options
-.\"man mdoc for the short list of editing options
-.\"/usr/share/misc/mdoc.template
-.Dd 9/18/06               \" DATE 
-.Dt xmlparser 1      \" Program name and manual section number 
-.Os Darwin
-.Sh NAME                 \" Section Header - required - don't modify 
-.Nm xmlparser,
-.\" The following lines are read in generating the apropos(man -k) database. Use only key
-.\" words here as the database is built based on the words here and in the .ND line. 
-.Nm Other_name_for_same_program(),
-.Nm Yet another name for the same program.
-.\" Use .Nm macro to designate other names for the documented program.
-.Nd This line parsed for whatis database.
-.Sh SYNOPSIS             \" Section Header - required - don't modify
-.Nm
-.Op Fl abcd              \" [-abcd]
-.Op Fl a Ar path         \" [-a path] 
-.Op Ar file              \" [file]
-.Op Ar                   \" [file ...]
-.Ar arg0                 \" Underlined argument - use .Ar anywhere to underline
-arg2 ...                 \" Arguments
-.Sh DESCRIPTION          \" Section Header - required - don't modify
-Use the .Nm macro to refer to your program throughout the man page like such:
-.Nm
-Underlining is accomplished with the .Ar macro like this:
-.Ar underlined text .
-.Pp                      \" Inserts a space
-A list of items with descriptions:
-.Bl -tag -width -indent  \" Begins a tagged list 
-.It item a               \" Each item preceded by .It macro
-Description of item a
-.It item b
-Description of item b
-.El                      \" Ends the list
-.Pp
-A list of flags and their descriptions:
-.Bl -tag -width -indent  \" Differs from above in tag removed 
-.It Fl a                 \"-a flag as a list item
-Description of -a flag
-.It Fl b
-Description of -b flag
-.El                      \" Ends the list
-.Pp
-.\" .Sh ENVIRONMENT      \" May not be needed
-.\" .Bl -tag -width "ENV_VAR_1" -indent \" ENV_VAR_1 is width of the string ENV_VAR_1
-.\" .It Ev ENV_VAR_1
-.\" Description of ENV_VAR_1
-.\" .It Ev ENV_VAR_2
-.\" Description of ENV_VAR_2
-.\" .El                      
-.Sh FILES                \" File used or created by the topic of the man page
-.Bl -tag -width "/Users/joeuser/Library/really_long_file_name" -compact
-.It Pa /usr/share/file_name
-FILE_1 description
-.It Pa /Users/joeuser/Library/really_long_file_name
-FILE_2 description
-.El                      \" Ends the list
-.\" .Sh DIAGNOSTICS       \" May not be needed
-.\" .Bl -diag
-.\" .It Diagnostic Tag
-.\" Diagnostic informtion here.
-.\" .It Diagnostic Tag
-.\" Diagnostic informtion here.
-.\" .El
-.Sh SEE ALSO 
-.\" List links in ascending order by section, alphabetically within a section.
-.\" Please do not reference files that do not exist without filing a bug report
-.Xr a 1 , 
-.Xr b 1 ,
-.Xr c 1 ,
-.Xr a 2 ,
-.Xr b 2 ,
-.Xr a 3 ,
-.Xr b 3 
-.\" .Sh BUGS              \" Document known, unremedied bugs 
+.\"Modified from man(1) of FreeBSD, the NetBSD mdoc.template, and mdoc.samples.
+.\"See Also:
+.\"man mdoc.samples for a complete listing of options
+.\"man mdoc for the short list of editing options
+.\"/usr/share/misc/mdoc.template
+.Dd 9/18/06               \" DATE 
+.Dt xmlparser 1      \" Program name and manual section number 
+.Os Darwin
+.Sh NAME                 \" Section Header - required - don't modify 
+.Nm xmlparser,
+.\" The following lines are read in generating the apropos(man -k) database. Use only key
+.\" words here as the database is built based on the words here and in the .ND line. 
+.Nm Other_name_for_same_program(),
+.Nm Yet another name for the same program.
+.\" Use .Nm macro to designate other names for the documented program.
+.Nd This line parsed for whatis database.
+.Sh SYNOPSIS             \" Section Header - required - don't modify
+.Nm
+.Op Fl abcd              \" [-abcd]
+.Op Fl a Ar path         \" [-a path] 
+.Op Ar file              \" [file]
+.Op Ar                   \" [file ...]
+.Ar arg0                 \" Underlined argument - use .Ar anywhere to underline
+arg2 ...                 \" Arguments
+.Sh DESCRIPTION          \" Section Header - required - don't modify
+Use the .Nm macro to refer to your program throughout the man page like such:
+.Nm
+Underlining is accomplished with the .Ar macro like this:
+.Ar underlined text .
+.Pp                      \" Inserts a space
+A list of items with descriptions:
+.Bl -tag -width -indent  \" Begins a tagged list 
+.It item a               \" Each item preceded by .It macro
+Description of item a
+.It item b
+Description of item b
+.El                      \" Ends the list
+.Pp
+A list of flags and their descriptions:
+.Bl -tag -width -indent  \" Differs from above in tag removed 
+.It Fl a                 \"-a flag as a list item
+Description of -a flag
+.It Fl b
+Description of -b flag
+.El                      \" Ends the list
+.Pp
+.\" .Sh ENVIRONMENT      \" May not be needed
+.\" .Bl -tag -width "ENV_VAR_1" -indent \" ENV_VAR_1 is width of the string ENV_VAR_1
+.\" .It Ev ENV_VAR_1
+.\" Description of ENV_VAR_1
+.\" .It Ev ENV_VAR_2
+.\" Description of ENV_VAR_2
+.\" .El                      
+.Sh FILES                \" File used or created by the topic of the man page
+.Bl -tag -width "/Users/joeuser/Library/really_long_file_name" -compact
+.It Pa /usr/share/file_name
+FILE_1 description
+.It Pa /Users/joeuser/Library/really_long_file_name
+FILE_2 description
+.El                      \" Ends the list
+.\" .Sh DIAGNOSTICS       \" May not be needed
+.\" .Bl -diag
+.\" .It Diagnostic Tag
+.\" Diagnostic informtion here.
+.\" .It Diagnostic Tag
+.\" Diagnostic informtion here.
+.\" .El
+.Sh SEE ALSO 
+.\" List links in ascending order by section, alphabetically within a section.
+.\" Please do not reference files that do not exist without filing a bug report
+.Xr a 1 , 
+.Xr b 1 ,
+.Xr c 1 ,
+.Xr a 2 ,
+.Xr b 2 ,
+.Xr a 3 ,
+.Xr b 3 
+.\" .Sh BUGS              \" Document known, unremedied bugs 
 .\" .Sh HISTORY           \" Document history if command behaves in a unique manner
\ No newline at end of file
diff --git a/unit-tests/src/xmlparser/xmlparser.m b/unit-tests/src/xmlparser/xmlparser.m
index a9c82fc..65f8a49 100644
--- a/unit-tests/src/xmlparser/xmlparser.m
+++ b/unit-tests/src/xmlparser/xmlparser.m
@@ -1,25 +1,25 @@
-#import <Foundation/Foundation.h>
-
-int main(int argc, char *argv[]) {
-	[[NSAutoreleasePool alloc] init];
-
-	if(argc != 2) {
-		NSLog(@"Usage: %s path-to-XML\n", argv[0]);
-		return 1;
-	}
-	NSString *path = [NSString stringWithUTF8String:argv[1]];
-
-	NSError *err = nil;
-	NSXMLDocument *doc = [[NSXMLDocument alloc]
-		initWithContentsOfURL:[NSURL
-			fileURLWithPath:path]
-		options:0
-		error:&err];
-	if(err) {
-		NSLog(@"ERROR: %@", err);
-		return 1;
-	} else {
-		NSLog(@"Parsed!");
-		return 0;
-	}
-}
+#import <Foundation/Foundation.h>
+
+int main(int argc, char *argv[]) {
+	[[NSAutoreleasePool alloc] init];
+
+	if(argc != 2) {
+		NSLog(@"Usage: %s path-to-XML\n", argv[0]);
+		return 1;
+	}
+	NSString *path = [NSString stringWithUTF8String:argv[1]];
+
+	NSError *err = nil;
+	NSXMLDocument *doc = [[NSXMLDocument alloc]
+		initWithContentsOfURL:[NSURL
+			fileURLWithPath:path]
+		options:0
+		error:&err];
+	if(err) {
+		NSLog(@"ERROR: %@", err);
+		return 1;
+	} else {
+		NSLog(@"Parsed!");
+		return 0;
+	}
+}
diff --git a/unit-tests/test-cases/exported_symbols_list-eol/test.exp b/unit-tests/test-cases/exported_symbols_list-eol/test.exp
index 6ab1532..93e7e17 100644
--- a/unit-tests/test-cases/exported_symbols_list-eol/test.exp
+++ b/unit-tests/test-cases/exported_symbols_list-eol/test.exp
@@ -1 +1,2 @@
-_func_global2_common_global2
\ No newline at end of file
+_func_global2
+_common_global2
-- 
1.7.1

